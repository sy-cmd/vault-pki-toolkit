#!/bin/bash
#
# cert-renewal-daemon
# Automated certificate renewal daemon for Vault PKI
#
# Author: Sydney Fwalanga
# Repository: https://github.com/sy-cmd/vault-pki-toolkit

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

# Default configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="${CONFIG_FILE:-/etc/vault-pki/renewal-daemon.conf}"
STATE_FILE="${STATE_FILE:-/var/lib/vault-pki/renewal-state.json}"

# Load configuration from file if exists
if [ -f "$CONFIG_FILE" ]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
fi

# Daemon settings (with defaults)
SCAN_INTERVAL="${SCAN_INTERVAL:-3600}"          # 1 hour
CERT_DIRECTORY="${CERT_DIRECTORY:-.}"
RECURSIVE="${RECURSIVE:-false}"
RENEWAL_THRESHOLD="${RENEWAL_THRESHOLD:-7}"     # Renew 7 days before expiry
MIN_REMAINING="${MIN_REMAINING:-1}"             # Minimum days before forced renewal

# Vault settings
VAULT_ADDR="${VAULT_ADDR:-http://127.0.0.1:8200}"
VAULT_TOKEN="${VAULT_TOKEN:-}"
PKI_PATH="${PKI_PATH:-pki_int}"
DEFAULT_ROLE="${DEFAULT_ROLE:-server}"

# Backup settings
BACKUP_OLD_CERTS="${BACKUP_OLD_CERTS:-true}"
BACKUP_DIRECTORY="${BACKUP_DIRECTORY:-/var/backups/certs}"

# Logging
LOG_FILE="${LOG_FILE:-/var/log/vault-pki/renewal.log}"
LOG_LEVEL="${LOG_LEVEL:-info}"                  # debug, info, warn, error

# Daemon control
PID_FILE="${PID_FILE:-/var/run/cert-renewal-daemon.pid}"
RUNNING=true

# Statistics
declare -A STATS
STATS[scans]=0
STATS[renewals_attempted]=0
STATS[renewals_success]=0
STATS[renewals_failed]=0

# Colors (only for terminal output)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# ============================================================================
# Logging Functions
# ============================================================================

log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Check log level
    case "$LOG_LEVEL" in
        debug) ;;
        info) [[ "$level" == "DEBUG" ]] && return ;;
        warn) [[ "$level" =~ ^(DEBUG|INFO)$ ]] && return ;;
        error) [[ "$level" != "ERROR" ]] && return ;;
    esac
    
    # Format log entry
    local log_entry="[${timestamp}] [${level}] ${message}"
    
    # Write to log file
    if [ -n "$LOG_FILE" ]; then
        echo "$log_entry" >> "$LOG_FILE"
    fi
    
    # Also output to console with colors
    case "$level" in
        ERROR)
            echo -e "${RED}${log_entry}${NC}" >&2
            ;;
        WARN)
            echo -e "${YELLOW}${log_entry}${NC}" >&2
            ;;
        INFO)
            echo -e "${GREEN}${log_entry}${NC}"
            ;;
        DEBUG)
            echo -e "${BLUE}${log_entry}${NC}"
            ;;
    esac
}

log_debug() { log "DEBUG" "$@"; }
log_info() { log "INFO" "$@"; }
log_warn() { log "WARN" "$@"; }
log_error() { log "ERROR" "$@"; }

# ============================================================================
# Certificate Discovery and Parsing
# ============================================================================

find_certificates() {
    local directory="$1"
    local recursive="$2"
    
    log_debug "Scanning directory: $directory (recursive: $recursive)"
    
    local find_cmd="find \"$directory\" -type f"
    
    if [ "$recursive" = "false" ]; then
        find_cmd="$find_cmd -maxdepth 1"
    fi
    
    find_cmd="$find_cmd \\( -name \"*.crt\" -o -name \"*.pem\" -o -name \"*.cert\" \\) 2>/dev/null"
    
    eval "$find_cmd"
}

get_cert_info() {
    local cert_file="$1"
    
    # Validate certificate
    if ! openssl x509 -in "$cert_file" -noout 2>/dev/null; then
        return 1
    fi
    
    # Extract common name
    local cn=$(openssl x509 -in "$cert_file" -noout -subject 2>/dev/null | \
        grep -oP 'CN\s*=\s*\K[^,]+' || echo "")
    
    # Get expiry date and calculate days remaining
    local expiry_date=$(openssl x509 -in "$cert_file" -noout -enddate 2>/dev/null | cut -d= -f2)
    local expiry_epoch=$(date -d "$expiry_date" +%s 2>/dev/null || \
        date -j -f "%b %d %H:%M:%S %Y %Z" "$expiry_date" +%s 2>/dev/null)
    local current_epoch=$(date +%s)
    local days_remaining=$(( ($expiry_epoch - $current_epoch) / 86400 ))
    
    echo "${cert_file}|${cn}|${days_remaining}|${expiry_date}"
}

needs_renewal() {
    local days_remaining="$1"
    
    if [ "$days_remaining" -lt "$MIN_REMAINING" ]; then
        return 0  # Force renewal
    elif [ "$days_remaining" -lt "$RENEWAL_THRESHOLD" ]; then
        return 0  # Within threshold
    else
        return 1  # Not yet
    fi
}

# ============================================================================
# Certificate Renewal Functions
# ============================================================================

backup_certificate() {
    local cert_file="$1"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="${BACKUP_DIRECTORY}/$(basename "$cert_file")-${timestamp}"
    
    if [ ! -d "$BACKUP_DIRECTORY" ]; then
        mkdir -p "$BACKUP_DIRECTORY"
    fi
    
    # Backup certificate and key
    cp "$cert_file" "${backup_name}.crt" 2>/dev/null || true
    
    local key_file="${cert_file%.*}.key"
    if [ -f "$key_file" ]; then
        cp "$key_file" "${backup_name}.key" 2>/dev/null || true
    fi
    
    log_debug "Backed up certificate: ${backup_name}"
}

renew_certificate() {
    local cert_file="$1"
    local common_name="$2"
    local output_dir=$(dirname "$cert_file")
    
    log_info "Attempting to renew certificate: $common_name"
    STATS[renewals_attempted]=$((${STATS[renewals_attempted]} + 1))
    
    # Backup old certificate if enabled
    if [ "$BACKUP_OLD_CERTS" = "true" ]; then
        backup_certificate "$cert_file"
    fi
    
    # Determine role from certificate metadata or use default
    local role="$DEFAULT_ROLE"
    
    # Extract SANs if present
    local sans=$(openssl x509 -in "$cert_file" -noout -text 2>/dev/null | \
        grep -A1 "Subject Alternative Name" | tail -n1 | \
        sed 's/DNS://g' | sed 's/,//g' | xargs || echo "")
    
    # Build request-cert command
    local request_cmd="${SCRIPT_DIR}/request-cert -n \"$common_name\" -o \"$output_dir\" -r \"$role\" --force"
    
    if [ -n "$sans" ]; then
        # Remove the CN from SANs if present
        sans=$(echo "$sans" | sed "s/$common_name//g" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | sed 's/[[:space:]]\+/,/g')
        if [ -n "$sans" ]; then
            request_cmd="$request_cmd -a \"$sans\""
        fi
    fi
    
    log_debug "Renewal command: $request_cmd"
    
    # Execute renewal
    if eval "$request_cmd" >> "$LOG_FILE" 2>&1; then
        log_info "Successfully renewed certificate: $common_name"
        STATS[renewals_success]=$((${STATS[renewals_success]} + 1))
        
        # Update state file
        update_state "$cert_file" "success" "$(date -Iseconds)"
        
        return 0
    else
        log_error "Failed to renew certificate: $common_name"
        STATS[renewals_failed]=$((${STATS[renewals_failed]} + 1))
        
        # Update state file
        update_state "$cert_file" "failed" "$(date -Iseconds)"
        
        return 1
    fi
}

# ============================================================================
# State Management
# ============================================================================

update_state() {
    local cert_file="$1"
    local status="$2"
    local timestamp="$3"
    
    local state_dir=$(dirname "$STATE_FILE")
    if [ ! -d "$state_dir" ]; then
        mkdir -p "$state_dir"
    fi
    
    # Initialize state file if doesn't exist
    if [ ! -f "$STATE_FILE" ]; then
        echo "{}" > "$STATE_FILE"
    fi
    
    # Update state using jq
    local temp_file=$(mktemp)
    jq --arg cert "$cert_file" \
       --arg status "$status" \
       --arg time "$timestamp" \
       '.[$cert] = {status: $status, timestamp: $time}' \
       "$STATE_FILE" > "$temp_file"
    
    mv "$temp_file" "$STATE_FILE"
}

get_last_renewal() {
    local cert_file="$1"
    
    if [ ! -f "$STATE_FILE" ]; then
        echo "never"
        return
    fi
    
    jq -r --arg cert "$cert_file" '.[$cert].timestamp // "never"' "$STATE_FILE" 2>/dev/null || echo "never"
}

# ============================================================================
# Main Scan and Renewal Logic
# ============================================================================

scan_and_renew() {
    log_info "Starting certificate scan (scan #$((${STATS[scans]} + 1)))"
    STATS[scans]=$((${STATS[scans]} + 1))
    
    local certs_found=0
    local certs_renewed=0
    local certs_failed=0
    
    # Find all certificates
    local cert_files=()
    while IFS= read -r cert_file; do
        [ -n "$cert_file" ] && cert_files+=("$cert_file")
    done < <(find_certificates "$CERT_DIRECTORY" "$RECURSIVE")
    
    log_info "Found ${#cert_files[@]} certificate(s) to check"
    
    # Check each certificate
    for cert_file in "${cert_files[@]}"; do
        certs_found=$((certs_found + 1))
        
        # Get certificate info
        local cert_info=$(get_cert_info "$cert_file")
        if [ -z "$cert_info" ]; then
            log_warn "Skipping invalid certificate: $cert_file"
            continue
        fi
        
        IFS='|' read -r file cn days_remaining expiry_date <<< "$cert_info"
        
        log_debug "Checking: $cn (expires in $days_remaining days)"
        
        # Check if renewal needed
        if needs_renewal "$days_remaining"; then
            log_info "Certificate needs renewal: $cn ($days_remaining days remaining)"
            
            if renew_certificate "$cert_file" "$cn"; then
                certs_renewed=$((certs_renewed + 1))
            else
                certs_failed=$((certs_failed + 1))
            fi
        else
            log_debug "Certificate OK: $cn ($days_remaining days remaining)"
        fi
    done
    
    # Log scan summary
    log_info "Scan complete: checked=$certs_found, renewed=$certs_renewed, failed=$certs_failed"
    
    # Log overall statistics
    log_info "Overall stats: scans=${STATS[scans]}, total_renewals=${STATS[renewals_success]}, failures=${STATS[renewals_failed]}"
}

# ============================================================================
# Daemon Control
# ============================================================================

setup_signal_handlers() {
    trap 'handle_shutdown' SIGTERM SIGINT
    trap 'log_debug "Received SIGHUP"' SIGHUP
}

handle_shutdown() {
    log_info "Received shutdown signal, stopping daemon..."
    RUNNING=false
    
    # Remove PID file
    if [ -f "$PID_FILE" ]; then
        rm -f "$PID_FILE"
    fi
    
    log_info "Daemon stopped gracefully"
    exit 0
}

write_pid_file() {
    local pid_dir=$(dirname "$PID_FILE")
    if [ ! -d "$pid_dir" ]; then
        mkdir -p "$pid_dir"
    fi
    
    echo $$ > "$PID_FILE"
}

check_prerequisites() {
    local errors=0
    
    # Check if vault CLI is available
    if ! command -v vault &> /dev/null; then
        log_error "vault CLI not found"
        errors=$((errors + 1))
    fi
    
    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        log_error "jq not found"
        errors=$((errors + 1))
    fi
    
    # Check if openssl is available
    if ! command -v openssl &> /dev/null; then
        log_error "openssl not found"
        errors=$((errors + 1))
    fi
    
    # Check if request-cert exists
    if [ ! -f "${SCRIPT_DIR}/request-cert" ]; then
        log_error "request-cert not found at ${SCRIPT_DIR}/request-cert"
        errors=$((errors + 1))
    fi
    
    # Check if certificate directory exists
    if [ ! -d "$CERT_DIRECTORY" ]; then
        log_error "Certificate directory not found: $CERT_DIRECTORY"
        errors=$((errors + 1))
    fi
    
    # Check Vault connectivity (non-fatal)
    if ! vault status &> /dev/null; then
        log_warn "Cannot connect to Vault at $VAULT_ADDR (continuing anyway)"
    fi
    
    return $errors
}

create_directories() {
    local dirs=(
        "$(dirname "$LOG_FILE")"
        "$(dirname "$STATE_FILE")"
        "$BACKUP_DIRECTORY"
    )
    
    for dir in "${dirs[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            log_debug "Created directory: $dir"
        fi
    done
}

show_usage() {
    cat << EOF
Usage: cert-renewal-daemon [OPTIONS]

Automated certificate renewal daemon for Vault PKI.

OPTIONS:
    -c, --config FILE       Configuration file (default: $CONFIG_FILE)
    -d, --directory DIR     Certificate directory to monitor
    -i, --interval SECONDS  Scan interval in seconds (default: 3600)
    -t, --threshold DAYS    Renewal threshold in days (default: 7)
    --foreground            Run in foreground (don't daemonize)
    -v, --verbose           Enable debug logging
    -h, --help              Show this help message

CONFIGURATION FILE:
    The daemon reads configuration from $CONFIG_FILE
    See config/renewal-daemon.conf.example for details

SIGNALS:
    SIGTERM, SIGINT         Graceful shutdown
    SIGHUP                  Reload configuration (future)

EXAMPLES:
    # Start daemon with default settings
    cert-renewal-daemon

    # Run in foreground with debug logging
    cert-renewal-daemon --foreground --verbose

    # Custom configuration
    cert-renewal-daemon -c /etc/vault-pki/custom.conf

EOF
    exit 0
}

# ============================================================================
# Main Function
# ============================================================================

main() {
    local foreground=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                ;;
            -c|--config)
                CONFIG_FILE="$2"
                shift 2
                ;;
            -d|--directory)
                CERT_DIRECTORY="$2"
                shift 2
                ;;
            -i|--interval)
                SCAN_INTERVAL="$2"
                shift 2
                ;;
            -t|--threshold)
                RENEWAL_THRESHOLD="$2"
                shift 2
                ;;
            --foreground)
                foreground=true
                shift
                ;;
            -v|--verbose)
                LOG_LEVEL="debug"
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                ;;
        esac
    done
    
    # Create necessary directories
    create_directories
    
    # Check prerequisites
    if ! check_prerequisites; then
        log_error "Prerequisites check failed, exiting"
        exit 1
    fi
    
    # Write PID file
    write_pid_file
    
    # Setup signal handlers
    setup_signal_handlers
    
    # Log startup
    log_info "=========================================="
    log_info "Certificate Renewal Daemon Starting"
    log_info "=========================================="
    log_info "Configuration:"
    log_info "  Certificate Directory: $CERT_DIRECTORY"
    log_info "  Scan Interval: ${SCAN_INTERVAL}s"
    log_info "  Renewal Threshold: ${RENEWAL_THRESHOLD} days"
    log_info "  Vault Address: $VAULT_ADDR"
    log_info "  PKI Path: $PKI_PATH"
    log_info "  Log File: $LOG_FILE"
    log_info "  Backup Directory: $BACKUP_DIRECTORY"
    log_info "=========================================="
    
    # Main daemon loop
    while [ "$RUNNING" = true ]; do
        scan_and_renew
        
        log_info "Next scan in ${SCAN_INTERVAL} seconds"
        sleep "$SCAN_INTERVAL" &
        wait $!
    done
}

# Run main function
main "$@"